-- Create tables (idempotent for new projects)
CREATE TABLE IF NOT EXISTS public.trades (
  id text primary key,
  "orderId" text,
  symbol text,
  side text,
  quantity numeric,
  price numeric,
  timestamp bigint,
  status text default 'OPEN',
  commission numeric,
  "commissionAsset" text,
  "stopLossPrice" numeric,
  "takeProfitPrice" numeric,
  "exitPrice" numeric,
  "exitTimestamp" bigint,
  "exitReason" text,  -- Reason for closing the trade (e.g., STOP_LOSS, TAKE_PROFIT, TRAILING_STOP_LOSS, STRATEGY_EXIT)
  "strategyName" text,  -- Name of the strategy that opened this trade
  leverage numeric,
  margin numeric,
  duration bigint,
  -- Trailing Stop Loss fields
  "trailingStopEnabled" boolean,
  "trailingStopActivated" boolean,
  "trailingStopActivationPercent" numeric,
  "trailingStopTrailPercent" numeric,
  "trailingStopHighPrice" numeric,  -- For BUY positions: highest price seen
  "trailingStopLowPrice" numeric,   -- For SELL positions: lowest price seen
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Portfolio Snapshots
CREATE TABLE IF NOT EXISTS public.portfolio_snapshots (
  id bigint generated by default as identity primary key,
  timestamp bigint,
  "totalValue" numeric,
  holdings jsonb,
  pnl numeric,
  "pnlPercentage" numeric,
  "winRate" numeric,
  "profitFactor" numeric,
  "winningTrades" integer,
  "losingTrades" integer,
  "openTradesCount" integer,
  "currentEquity" numeric,
  "currentBalance" numeric,
  "walletBalance" numeric,
  "totalMarginUsed" numeric,
  "totalNotionalValue" numeric,
  "initialBalance" numeric,
  created_at timestamp with time zone default timezone('utc'::text, now())
);
CREATE INDEX IF NOT EXISTS idx_portfolio_snapshots_timestamp ON public.portfolio_snapshots (timestamp DESC);

-- Portfolio Chart Cache (Optimized for instant dashboard loading)
CREATE TABLE IF NOT EXISTS public.portfolio_chart_cache (
  period text primary key, -- e.g. '1d', '1w', '1m', '1y', 'all'
  data jsonb not null, -- Array of {timestamp, equity} points
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

-- Backtest Results
CREATE TABLE IF NOT EXISTS public.backtest_results (
  id bigint generated by default as identity primary key,
  timestamp bigint,
  result jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- Application State Persistence
CREATE TABLE IF NOT EXISTS public.kv_store (
  key text primary key,
  value jsonb not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);
COMMENT ON TABLE public.kv_store IS 'Generic key-value store for persisting application state (e.g. risk limits)';

-- Vault Transactions Table
CREATE TABLE IF NOT EXISTS public.vault_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    amount NUMERIC NOT NULL,
    shares NUMERIC NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('DEPOSIT', 'WITHDRAWAL')),
    timestamp BIGINT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- Vault State Table (Singleton)
CREATE TABLE IF NOT EXISTS public.vault_state (
    id INT PRIMARY KEY DEFAULT 1,
    total_assets NUMERIC DEFAULT 0,
    total_shares NUMERIC DEFAULT 0,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    CONSTRAINT singleton CHECK (id = 1)
);

-- Add vault-related comments
COMMENT ON TABLE public.vault_transactions IS 'Logs all deposits and withdrawals from the paper trading vault';
COMMENT ON TABLE public.vault_state IS 'Real-time summary of the vault total value and total issued shares';

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on trading tables (accessed by authenticated users)
-- Note: These ALTER statements are idempotent - they won't error if already enabled
DO $$
BEGIN
    -- Enable RLS on trading tables
    ALTER TABLE public.trades ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_chart_cache ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.backtest_results ENABLE ROW LEVEL SECURITY;
    ALTER TABLE public.kv_store ENABLE ROW LEVEL SECURITY;
EXCEPTION
    WHEN others THEN
        -- Ignore errors if RLS is already enabled
        NULL;
END $$;

-- DISABLE RLS on wallet tables (server-side API access only)
-- These tables are accessed only through authenticated server APIs using service role.
-- Security is handled at the application level, not database level.
DO $$
BEGIN
    ALTER TABLE public.vault_transactions DISABLE ROW LEVEL SECURITY;
    ALTER TABLE public.vault_state DISABLE ROW LEVEL SECURITY;
    ALTER TABLE public.portfolio_snapshots DISABLE ROW LEVEL SECURITY;
EXCEPTION
    WHEN others THEN
        -- Ignore errors if RLS is already disabled
        NULL;
END $$;

-- ============================================================================
-- RLS POLICIES (Idempotent for new projects)
-- ============================================================================

-- Create policies with error handling for existing projects
DO $$
BEGIN
    -- Trades table policies
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'trades' AND policyname = 'Allow authenticated read access to trades') THEN
        CREATE POLICY "Allow authenticated read access to trades" ON public.trades FOR SELECT TO authenticated USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'trades' AND policyname = 'Allow authenticated insert access to trades') THEN
        CREATE POLICY "Allow authenticated insert access to trades" ON public.trades FOR INSERT TO authenticated WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'trades' AND policyname = 'Allow authenticated update access to trades') THEN
        CREATE POLICY "Allow authenticated update access to trades" ON public.trades FOR UPDATE TO authenticated USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'trades' AND policyname = 'Allow authenticated delete access to trades') THEN
        CREATE POLICY "Allow authenticated delete access to trades" ON public.trades FOR DELETE TO authenticated USING (true);
    END IF;

    -- Portfolio snapshots policies
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_snapshots' AND policyname = 'Allow authenticated read access to portfolio_snapshots') THEN
        CREATE POLICY "Allow authenticated read access to portfolio_snapshots" ON public.portfolio_snapshots FOR SELECT TO authenticated USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_snapshots' AND policyname = 'Allow authenticated insert access to portfolio_snapshots') THEN
        CREATE POLICY "Allow authenticated insert access to portfolio_snapshots" ON public.portfolio_snapshots FOR INSERT TO authenticated WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_snapshots' AND policyname = 'Allow authenticated update access to portfolio_snapshots') THEN
        CREATE POLICY "Allow authenticated update access to portfolio_snapshots" ON public.portfolio_snapshots FOR UPDATE TO authenticated USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_snapshots' AND policyname = 'Allow authenticated delete access to portfolio_snapshots') THEN
        CREATE POLICY "Allow authenticated delete access to portfolio_snapshots" ON public.portfolio_snapshots FOR DELETE TO authenticated USING (true);
    END IF;

    -- Portfolio chart cache policies
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_chart_cache' AND policyname = 'Allow authenticated read access to portfolio_chart_cache') THEN
        CREATE POLICY "Allow authenticated read access to portfolio_chart_cache" ON public.portfolio_chart_cache FOR SELECT TO authenticated USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_chart_cache' AND policyname = 'Allow authenticated insert access to portfolio_chart_cache') THEN
        CREATE POLICY "Allow authenticated insert access to portfolio_chart_cache" ON public.portfolio_chart_cache FOR INSERT TO authenticated WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_chart_cache' AND policyname = 'Allow authenticated update access to portfolio_chart_cache') THEN
        CREATE POLICY "Allow authenticated update access to portfolio_chart_cache" ON public.portfolio_chart_cache FOR UPDATE TO authenticated USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'portfolio_chart_cache' AND policyname = 'Allow authenticated delete access to portfolio_chart_cache') THEN
        CREATE POLICY "Allow authenticated delete access to portfolio_chart_cache" ON public.portfolio_chart_cache FOR DELETE TO authenticated USING (true);
    END IF;

    -- Backtest results policies
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'backtest_results' AND policyname = 'Allow authenticated read access to backtest_results') THEN
        CREATE POLICY "Allow authenticated read access to backtest_results" ON public.backtest_results FOR SELECT TO authenticated USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'backtest_results' AND policyname = 'Allow authenticated insert access to backtest_results') THEN
        CREATE POLICY "Allow authenticated insert access to backtest_results" ON public.backtest_results FOR INSERT TO authenticated WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'backtest_results' AND policyname = 'Allow authenticated update access to backtest_results') THEN
        CREATE POLICY "Allow authenticated update access to backtest_results" ON public.backtest_results FOR UPDATE TO authenticated USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'backtest_results' AND policyname = 'Allow authenticated delete access to backtest_results') THEN
        CREATE POLICY "Allow authenticated delete access to backtest_results" ON public.backtest_results FOR DELETE TO authenticated USING (true);
    END IF;

    -- KV store policies
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'kv_store' AND policyname = 'Allow authenticated read access to kv_store') THEN
        CREATE POLICY "Allow authenticated read access to kv_store" ON public.kv_store FOR SELECT TO authenticated USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'kv_store' AND policyname = 'Allow authenticated insert access to kv_store') THEN
        CREATE POLICY "Allow authenticated insert access to kv_store" ON public.kv_store FOR INSERT TO authenticated WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'kv_store' AND policyname = 'Allow authenticated update access to kv_store') THEN
        CREATE POLICY "Allow authenticated update access to kv_store" ON public.kv_store FOR UPDATE TO authenticated USING (true) WITH CHECK (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'kv_store' AND policyname = 'Allow authenticated delete access to kv_store') THEN
        CREATE POLICY "Allow authenticated delete access to kv_store" ON public.kv_store FOR DELETE TO authenticated USING (true);
    END IF;

EXCEPTION
    WHEN others THEN
        -- Ignore errors if policies already exist
        NULL;
END $$;

-- ============================================================================
-- WALLET TABLES SECURITY NOTE
-- ============================================================================
-- vault_transactions, vault_state, and portfolio_snapshots have RLS DISABLED
-- These tables are only accessed through authenticated server-side APIs
-- Security is enforced at the application level using JWT authentication
-- and service role database access. No direct user access to these tables.

